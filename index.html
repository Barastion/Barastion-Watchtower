<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor Odwiedzin</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Monitor Odwiedzin</h1>
        <div class="content-wrapper">
            <div class="log-table">
                <table id="logTable">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Godzina</th>
                            <th>IP</th>
                            <th>Przeglądarka</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody"></tbody>
                </table>
            </div>
            <div class="weather-info">
                <h2>Pogoda dla Twojej lokalizacji</h2>
                <p>Aktualna temperatura: <span id="currentTemp">-</span>°C</p>
                <h3>Prognoza na następne dni</h3>
                <ul id="weatherForecast"></ul>
            </div>
        </div>
    </div>

    <script>
        const CLIENT_ID = '183075047643-uo1onbpgq7ebpru4br02o87a4fjhjssc.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyAy8hRvI87HpyuO-eB791Ntnn7U_tmtrYU';
        const FILE_ID = '1h720TRMofpJ0G6VXFg-H6j5XL3GKGhx8nPl-IZFrbR8';
        const SCOPE = 'https://www.googleapis.com/auth/drive.file';

        let token = null;
        let lastIpLogTime = {}; // Obiekt do śledzenia ostatniego logowania dla każdego IP

        // Dynamiczne ładowanie skryptu Google API
        function loadGoogleApiScript() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://apis.google.com/js/api.js';
                script.async = true;
                script.crossOrigin = 'anonymous'; // Dodane dla lepszej obsługi CSP
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Nie udało się załadować Google API'));
                document.head.appendChild(script);
            });
        }

        async function initGoogleAPI() {
            try {
                await loadGoogleApiScript();
                await new Promise(resolve => gapi.load('client:auth2', resolve));
                await gapi.client.init({
                    apiKey: API_KEY,
                    clientId: CLIENT_ID,
                    scope: SCOPE,
                });
                token = gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token;
                console.log('Zalogowano pomyślnie, token:', token);
                await loadLogsFromDrive(); // Pobierz logi przy inicjalizacji
                setInterval(syncLogsWithGoogleDrive, 300000); // Synchronizacja co 5 minut
            } catch (error) {
                console.error('Błąd inicjalizacji Google API:', error);
                // W przypadku błędu użyj buforowanych logów z localStorage
                const cachedLogs = JSON.parse(localStorage.getItem('visitLogs')) || [];
                displayLogs(cachedLogs);
            }
        }

        function updateSigninStatus(isSignedIn) {
            if (!isSignedIn) {
                console.log('Próba logowania...');
                gapi.auth2.getAuthInstance().signIn();
            }
        }

        async function getIp() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip || 'Nieznany IP';
            } catch (err) {
                console.error('Błąd pobierania IP:', err);
                return 'Nieznany IP';
            }
        }

        function getBrowser() {
            const userAgent = navigator.userAgent;
            return userAgent.match(/(Chrome|Firefox|Safari|Edge)/) ? userAgent.match(/(Chrome|Firefox|Safari|Edge)/)[0].slice(0, 10) : 'Nieznana';
        }

        // Pobierz logi z Google Drive
        async function fetchLogs() {
            try {
                const response = await fetch(`https://www.googleapis.com/drive/v3/files/${FILE_ID}?alt=media`, {
                    headers: { Authorization: `Bearer ${token}` },
                });
                if (!response.ok) throw new Error('Błąd pobierania logów z Google Drive: ' + response.status);
                const text = await response.text();
                const lines = text.trim().split('\n').filter(line => line.trim() !== '');
                return lines.map(line => {
                    try {
                        return JSON.parse(line); // Próbujemy parsować jako JSON
                    } catch (e) {
                        // Jeśli nie można sparsować jako JSON, zakładamy, że to stary format tekstowy
                        const [date, time, ip, browser] = line.split(' | ');
                        return { date, time, ip, browser };
                    }
                });
            } catch (err) {
                console.error('Błąd fetchLogs:', err);
                return []; // Zwracamy pustą tablicę w przypadku błędu
            }
        }

        // Zapisz logi do Google Drive
        async function saveLogs(logs) {
            try {
                const boundary = '-------314159265358979323846';
                const delimiter = `\r\n--${boundary}\r\n`;
                const closeDelim = `\r\n--${boundary}--`;
                const contentType = 'text/plain';
                const metadata = { name: 'logs.txt', mimeType: contentType };
                const multipartRequestBody =
                    delimiter +
                    'Content-Type: application/json\r\n\r\n' +
                    JSON.stringify(metadata) +
                    delimiter +
                    `Content-Type: ${contentType}\r\n\r\n` +
                    logs.map(log => JSON.stringify(log)).join('\n') +
                    closeDelim;

                const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${FILE_ID}?uploadType=multipart`, {
                    method: 'PATCH',
                    headers: { Authorization: `Bearer ${token}` },
                    body: multipartRequestBody,
                });
                if (!response.ok) throw new Error('Błąd zapisywania logów do Google Drive: ' + response.status);
                console.log('Logi zapisane do Google Drive');
                localStorage.setItem('visitLogs', JSON.stringify(logs)); // Zaktualizuj localStorage
            } catch (err) {
                console.error('Błąd saveLogs:', err);
                // Zapisz do localStorage jako backup
                localStorage.setItem('visitLogs', JSON.stringify(logs));
            }
        }

        // Zapis wizyty z synchronizacją do Google Drive
        function logVisit() {
            const now = new Date();
            const date = now.toLocaleDateString('pl-PL', { day: '2-digit', month: '2-digit', year: 'numeric' });
            const time = now.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
            getIp().then(ip => {
                const browser = getBrowser();
                const logEntry = { date, time, ip, browser };

                checkDDoSProtection(ip, async () => {
                    try {
                        let logs = await fetchLogs() || [];
                        logs.unshift(logEntry); // Nowe logi na górze
                        if (logs.length > 50) logs.pop(); // Ograniczenie do 50 najnowszych logów
                        await saveLogs(logs);
                        displayLogs(logs);
                    } catch (err) {
                        console.error('Błąd logVisit:', err);
                        // Jeśli Google Drive nie działa, użyj localStorage jako backup
                        let localLogs = JSON.parse(localStorage.getItem('visitLogs')) || [];
                        localLogs.unshift(logEntry);
                        if (localLogs.length > 50) localLogs.pop();
                        localStorage.setItem('visitLogs', JSON.stringify(localLogs));
                        displayLogs(localLogs);
                    }
                });
            });
        }

        // Wyświetlanie logów w tabeli bez numerków
        function displayLogs(logs) {
            const logTableBody = document.getElementById('logTableBody');
            if (!logTableBody) {
                console.error('Element logTableBody nie istnieje w DOM');
                return;
            }
            logTableBody.innerHTML = '';
            logs.forEach(log => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${log.date || 'Nieznana'}</td>
                    <td>${log.time || 'Nieznana'}</td>
                    <td>${log.ip || 'Nieznany'}</td>
                    <td>${log.browser || 'Nieznana'}</td>
                `;
                logTableBody.appendChild(row);
            });
        }

        // Ochrona przed DDoS – zapisujemy logi tylko raz na minutę dla każdego IP
        function checkDDoSProtection(ip, callback) {
            const currentTime = Date.now();
            if (lastIpLogTime[ip]) {
                const timeDiff = (currentTime - lastIpLogTime[ip]) / 1000 / 60; // W minutach
                if (timeDiff < 1) {
                    console.log('Ograniczenie logowania – zbyt częste z tego samego IP');
                    return false; // Nie zapisujemy, jeśli minęła mniej niż minuta
                }
            }
            lastIpLogTime[ip] = currentTime;
            callback();
            return true;
        }

        // Synchronizacja z Google Drive (opcjonalna, co 5 minut)
        async function syncLogsWithGoogleDrive() {
            if (!token) {
                console.log('Brak tokena autoryzacji – synchronizacja opóźniona');
                return;
            }

            let localLogs = JSON.parse(localStorage.getItem('visitLogs')) || [];
            try {
                const driveLogs = await fetchLogs();
                const uniqueLogs = [...new Map([...driveLogs, ...localLogs].map(item => [JSON.stringify(item), item])).values()];
                if (uniqueLogs.length > 50) uniqueLogs.length = 50; // Ograniczenie do 50
                await saveLogs(uniqueLogs);
                localStorage.setItem('visitLogs', JSON.stringify(uniqueLogs));
                displayLogs(uniqueLogs);
            } catch (err) {
                console.error('Błąd synchronizacji z Google Drive:', err);
            }
        }

        // Pobierz logi z Google Drive przy starcie
        async function loadLogsFromDrive() {
            try {
                const logs = await fetchLogs();
                if (logs.length > 0) {
                    localStorage.setItem('visitLogs', JSON.stringify(logs.slice(0, 50))); // Ograniczenie do 50
                    displayLogs(logs.slice(0, 50));
                }
            } catch (err) {
                console.error('Błąd pobierania logów z Google Drive:', err);
                // Użyj logów lokalnych jako backup
                const localLogs = JSON.parse(localStorage.getItem('visitLogs')) || [];
                displayLogs(localLogs);
            }
        }

        // Pobierz pogodę dla lokalizacji IP
        async function getWeather(ip) {
            try {
                const locationResponse = await fetch(`https://ipapi.co/${ip}/json/`);
                const locationData = await locationResponse.json();
                const lat = locationData.latitude;
                const lon = locationData.longitude;

                const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=YOUR_OPENWEATHERMAP_API_KEY&units=metric&lang=pl`);
                const weatherData = await weatherResponse.json();
                const forecastResponse = await fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=YOUR_OPENWEATHERMAP_API_KEY&units=metric&lang=pl`);
                const forecastData = await forecastResponse.json();

                document.getElementById('currentTemp').textContent = weatherData.main.temp.toFixed(1);
                
                const forecastList = document.getElementById('weatherForecast');
                forecastList.innerHTML = '';
                const dailyForecast = {};
                forecastData.list.forEach(item => {
                    const date = new Date(item.dt * 1000).toLocaleDateString('pl-PL', { day: 'numeric', month: 'numeric', year: 'numeric' });
                    if (!dailyForecast[date]) {
                        dailyForecast[date] = item.main.temp;
                    }
                });
                for (const [date, temp] of Object.entries(dailyForecast)) {
                    const li = document.createElement('li');
                    li.textContent = `${date}: ${temp.toFixed(1)}°C`;
                    forecastList.appendChild(li);
                }
            } catch (err) {
                console.error('Błąd pobierania pogody:', err);
                document.getElementById('currentTemp').textContent = 'Błąd';
                document.getElementById('weatherForecast').innerHTML = '<li>Błąd pobierania prognozy</li>';
            }
        }

        // Inicjalizacja przy załadowaniu strony
        window.onload = function() {
            initGoogleAPI();
            getIp().then(ip => {
                if (checkDDoSProtection(ip, logVisit)) {
                    logVisit(); // Zapisujemy log tylko jeśli ochrona DDoS pozwala
                }
                getWeather(ip); // Pobierz pogodę dla lokalizacji IP
            });
        };

        // Opcjonalna synchronizacja przy zamknięciu strony
        window.onunload = function() {
            syncLogsWithGoogleDrive();
        };
    </script>
</body>
</html>
